"""Read YAML metadata files, set DOIs for resources that miss one."""

import argparse
import netrc
import re
import sys
import traceback
from collections import defaultdict
from pathlib import Path

import requests
import yaml
from requests.auth import HTTPBasicAuth

# from collections import defaultdict
# from translate_lang import get_lang_names
# from datacite import DataCiteMDSClient, schema45

try:
    YAML_DIR = Path("../metadata/yaml")
    PID_KEY = "pid"
    DMS_URL = "https://api.test.datacite.org/dois"
    DMS_AUTH_USER, DMS_AUTH_ACCOUNT, DMS_AUTH_PASSWORD = netrc.netrc().authenticators("example.com")  # TODO: error checking
    DMS_HEADERS = {"content-type": "application/json"}
    DMS_PREFIX = "10.23695"
    DMS_REPOID = "SND.SPRKB"
    DMS_CREATOR_NAME = "Språkbanken Text"
    DMS_CREATOR_ROR = "https://ror.org/12345"  # TODO
    DMS_TARGET_URL_PREFIX = "https://spraakbanken.gu.se/en/resources/"
    DMS_RESOURCE_TYPE_GENERAL = "Dataset"
    DMS_DEFAULT_YEAR = "2024"

    RESPONSE_OK = 200

except Exception as e:
    print("Error: failed init.")
    print(traceback.format_exc())
    sys.exit()


"""Test repo"""
DMS_URL = "https://doi.test.datacite.org/"
DMS_PREFIX = "10.80338"
DMS_REPOID = "PMAL.RUSOIT"
DMS_AUTH_USER = DMS_REPOID
DMS_AUTH_PASSWORD = "spraakbanken7!"
DMS_CREATOR_ROR = ""



# Instantiate command line arg parser
parser = argparse.ArgumentParser(description="Read YAML metadata files, create PIDs for those that are missing it, create and update Datacite metadata.")
parser.add_argument("--debug", action="store_true", help="Print debug info")
parser.add_argument("--test", action="store_true", help="Test - don't write")


def str_presenter(dumper, data):
    """Configure yaml package for dumping multiline strings (for preserving format).

    # https://github.com/yaml/pyyaml/issues/240
    # https://pythonhint.com/post/9957829820118202/yamldump-adding-unwanted-newlines-in-multiline-strings
    # Ref: https://stackoverflow.com/questions/8640959/how-can-i-control-what-scalar-form-pyyaml-uses-for-my-data
    """
    if data.count("\n") > 0:  # check for multiline string
        return dumper.represent_scalar("tag:yaml.org,2002:str", data, style="|")
    return dumper.represent_scalar("tag:yaml.org,2002:str", data)


yaml.add_representer(str, str_presenter)
yaml.representer.SafeRepresenter.add_representer(str, str_presenter)


class IndentDumper(yaml.Dumper):
    """Indent list items (for preserving format).

    https://reorx.com/blog/python-yaml-tips/#enhance-list-indentation-dump
    """

    def increase_indent(self, flow=False):  # noqa: D102, ANN201, ANN001
        return super(IndentDumper, self).increase_indent(flow, False)  # noqa


def main(debug: bool=False, test: bool=False) -> None:
    """Read YAML metadata files, compile and prepare information for the API (main wrapper)."""
    resources = {}  # set, not possible to change items

    # 1. get all resources

    resources = {}
    files_yaml = {}

    # Path.glob(pattern, *, case_sensitive=None) - returns list of found files
    # **/*.yaml - all files in this dir and subdirs, recursively
    # https://python.land/data-processing/python-yaml#Reading_and_parsing_a_YAML_file_with_Python
    for filepath in sorted(YAML_DIR.glob("**/*.yaml")):
        # Get resources from yaml
        # TODO error handling
        res_id = filepath.stem
        files_yaml[res_id] = filepath
        with filepath.open(encoding="utf-8") as file_yaml:
            res = yaml.safe_load(file_yaml)
            resources[res_id] = res

    # 2. Assign PIDs (so both Collections and Resources have them)
    # TODO lookup if there is an existing Handle from SweClarin repos
    # TODO Error handling, logging
    for res_id, res in resources.items():
        if res:  # noqa: SIM102
            if PID_KEY not in res:
                # Metadata.yaml could be autogenerated, so look up if it already exists
                # even though resource has no PID in metadata
                # Unique key for a resource is res_id
                pid = get_dms_lookup_pid(res_id)
                if not pid:
                    # gen PID
                    pid = get_dms_pid(res_id, res)
                if pid:
                    resources[res_id][PID_KEY] = pid
                else:
                    pass
                    # log failure

    """3. Save as YAML (prev json)"""
    for res_id, res in resources.items():
        if res:
            with files_yaml[res_id].open("w") as file_yaml:
                yaml.dump(
                    res, file_yaml, Dumper=IndentDumper, sort_keys=False, default_flow_style=False, allow_unicode=True
                )

    """4. Map Collections and Resources in both directions

    Datacite Metadata Schema field 12 - RelatedIdentifier
    All resources now have PIDs.
    All previous related identifiers are removed when setting new field.

    A. First fill IsPartOf list.
    """
    c = dict()
    for res_id, res in resources.items():
        if get_key_value(res, "collection"):
            if res_id not in c:
                c[res_id] = dict()
                c[res_id]['HasPart'] = defaultdict(list)
                c[res_id]['IsPartOf'] = defaultdict(list)
        member_list = get_key_list_value(res, "in_collection")
        if member_list:
            if res_id not in c:
                c[res_id] = dict()
                c[res_id]['HasPart'] = defaultdict(list)
                c[res_id]['IsPartOf'] = defaultdict(list)
            for c_res_id in member_list:
                if c_res_id not in c[res_id]['IsPartOf']:
                    c[res_id]['IsPartOf'].append(c_res_id)
    """B. Now fill HasPart list"""
    for res_id in c.items():
        for c_res_id in c[res_id]['IsPartOf']:
            if res_id not in c[c_res_id]['HasPart']:
                c[c_res_id]['HasPart'].append(res_id)
    """Update DMS"""
    for res_id in c.items():
        set_dms_related(res, res_id, c[res_id]['HasPart'], c[res_id]['IsPartof'])
    
    """TODO successors

    successors:
        - sweanalogy
    """
    # TODO Obsoletes/IsObsoletedBy???
    # TODO unlisted: true ???


def get_dms_pid(res_id: str, res: str) -> str:
    """Construct DMS and call Datacite API."""
    data_json = {
        "data": {
            "type": "dois",
            "attributes": {
                # M - Mandatory. R - recommended. O - optional.
                # 1 - 1 value allowed. n - multiple values allowed.
                # 1. M1. DOI
                "event": "publish",
                "prefix": DMS_PREFIX,
                # 2. Mn. Creator
                "creators": [
                    {
                        "name": DMS_CREATOR_NAME,
                        "nameType": "Organizational",
                        "nameIdentifiers": [
                            {
                                "schemeURI": "https://ror.org/",
                                "nameIdentifier": DMS_CREATOR_ROR,
                                "nameIdentifierScheme": "ROR",
                            }
                        ],
                    }
                ],
                # 3. Mn. Title
                "titles": [
                    {"lang": "se", "title": res["name"]["swe"]},
                    {
                        "lang": "en",
                        "title": res["name"]["eng"],
                    },
                ],
                # 4. M1. Publisher
                "publisher": {
                    "name": DMS_CREATOR_NAME,
                    "publisherIdentifier": DMS_CREATOR_ROR,
                    "publisherIdentifierScheme": "ROR",
                    "schemeURI": "https://ror.org/",
                },
                # 5. M1. Publication date
                "publicationYear": DMS_DEFAULT_YEAR,
                # 6. Rn. Subject
                "subjects": [
                    {
                        "subject": "Language Technology (Computational Linguistics)",
                        "subjectScheme": "Standard för svensk indelning av forskningsämnen 2011",
                        "classificationCode": "10208",
                        "schemeURI": "https://www.scb.se/dokumentation/klassifikationer-och-standarder/standard-for-svensk-indelning-av-forskningsamnen",
                    }
                ],
                # 7. Rn. Contributor (skip)
                "contributors": [],
                # 8. Rn. Dates (skip for now)
                "dates": [],
                # 9. O1. Primary language
                "language": get_res_lang_code(get_key_value(res, "language_codes")),
                # 10. M1. Resource type, Type/TypeGeneral should form a pair
                "types": {"resourceType": get_key_value(res, "type"), "resourceTypeGeneral": DMS_RESOURCE_TYPE_GENERAL},
                # 11. On. Alternate identifier
                # resource ID (which is unique within Språkbanken Text)
                # TODO Handle for SweClarin repo
                "alternateIdentifiers": [
                    {"alternateIdentifierType": "resource ID", "alternateIdentifier": res_id},
                    {"alternateIdentifierType": "Handle", "alternateIdentifier": ""},
                ],
                # 12. Rn. Related identifier (set later for collections)
                "relatedIdentifiers": [],
                # 13. On. Size.
                "sizes": [get_res_size(get_key_value(res, "size"))],
                # 14. On. Formatres_id
                # 17. Rn. Description take short and filter HTML
                "descriptions": [
                    {
                        "lang": "se",
                        "description": get_clean_string(res["short_description"]["swe"]),
                        "descriptionType": "Abstract",
                    },
                    {
                        "lang": "en",
                        "description": get_clean_string(res["short_description"]["eng"]),
                        "descriptionType": "Abstract",
                    },
                ],
                # 18. Rn. Geolocation (skip)
                "geoLocations": [],
                # 19. On. Funding (skip for now)
                "fundingReferences": [], 
                # 20. On. Related items that don't have an ID/PID
                "relatedItems": [],
                # DOI target
                "url": DMS_TARGET_URL_PREFIX + res_id,
            },  # attributes
        }  # data
    }

    # TODO Validate

    # Register resource
    response = requests.post(
        DMS_URL, json=data_json, headers=DMS_HEADERS, auth=HTTPBasicAuth(DMS_AUTH_USER, DMS_AUTH_PASSWORD)
    )
    """
    url = "https://api.datacite.org/dois/10.14454/FXWS-0523"
    response = requests.get(url)
    d = response.json()
    print(d["data"]["id"])

    https://datagy.io/python-requests-json/
    """
    if response.status_code == RESPONSE_OK:
        d = response.json()
        if "data" in d:
            data = d["data"]
            if type(data) is list:  # noqa: SIM108
                # TODO This should never happen, as res_id should be unique among Språkbanken Text
                pid = data[0]["id"]
            else:
                pid = data["id"]
        else:
            # print(d["errors"][0]["status"]) # returns "404"
            pid = ""

    return pid


"""
Helper functions for get_dms_pid()
"""


def get_res_lang_code(language_list: list) -> str:
    """Translate code to ISO right version."""
    if language_list:
        return language_list[0]
    else:
        pass


def get_res_size(size_list: list) -> str:
    """Create string of resource size info."""
    result = ""
    if type(size_list) is list:
        for key, value in size_list.items():
            if result:
                result += ". " + key + ": " + value
            else:
                result = key + ": " + value
    return result


def get_res_format(downloads_list: list) -> str:
    """Create string of download URLs."""
    result = ""
    for key, value in downloads_list.items():
        if key == "format":
            if result:
                result += ", " + value
            else:
                result = value
    return result


def get_res_right(downloads_list: list) -> str:
    """Create string of resource rights information."""
    result = ""
    for key, value in downloads_list.items():
        if key == "licence":
            if result:
                result += ", "
            result = '{"rights": ' + value + '"}'
    return result


def get_clean_string(string: str) -> str:
    """Remove HTML from string."""
    return re.sub(r"<.*?>", "", string)


def get_key_value(dictionary: dict, key: str) -> str:
    """Return key value from dictionary, else empty string."""
    return dictionary.get(key, "")


def get_key_list_value(dictionary: dict, key: str) -> list:
    """Return key value from dictionary, else empty list, []."""
    return dictionary.get(key, [])


def get_pid_from_rid(res: dict, rid: str) -> str:
    """Return PID (DOI) belonging to a resource ID.

    Arguments:
        res {dict} -- Resources
        rid {str} -- resource ID

    Returns:
        str -- PID (DOI) or "" if rid not found.
    """
    if rid in res:
        if 'pid' in res[rid]:
            return res[rid]['pid']
    return ""

def set_dms_related(res: dict, rid: str, has_part: list, is_part_of: list) -> bool:
    """Set related identifiers for resource, both collections and members.

    Arguments:
        rid {str} -- ID of resource.
        has_part {list} -- list of resources (resource IDs) that the entity is collection for (HasPart).
        is_part_of {list} -- list of resources (resource IDs) that the entity is a member of (IsPartOf).

    Returns:
        bool -- Success.
    """
    # Build list of relatedIdentifiers (HasPart)
    result = ""
    for related_rid in has_part:
        if result:
            result += ", "
        result += (
            ', {"relatedIdentifierType": "DOI", '
            ' "relationType": "HasPart", '
            ' "resourceTypeGeneral": '
            + DMS_RESOURCE_TYPE_GENERAL +
            + ", "
            + ' "relatedIdentifier": "'
            + get_pid_from_rid(related_rid, res)
            + '"}'
        )


    # Build list of relatedIdentifiers (IsPartOf)
    result = ""
    for related_rid in is_part_of:
        if result:
            result += ", "
        result += (
            ', {"relatedIdentifierType": "DOI", '
            ' "relationType": "IsPartOf", '
            ' "resourceTypeGeneral": '
            + DMS_RESOURCE_TYPE_GENERAL +
            + ", "
            + ' "relatedIdentifier": "'
            + get_pid_from_rid(related_rid, res)
            + '"}'
        )

    # Build json payload
    data_json = {
        "data": {
            "type": "dois",
            "attributes": {
                # 12. Rn. Related identifier (set later for collections)
                "relatedIdentifiers": [result]
            },
        }
    }

    # Update resource
    url = DMS_URL + "/" + get_pid_from_rid(rid, res)
    response = requests.put(
        url, json=data_json, headers=DMS_HEADERS, auth=HTTPBasicAuth(DMS_AUTH_USER, DMS_AUTH_PASSWORD)
    )

    # dict = response.json()
    return response.status_code == RESPONSE_OK




def set_dms_has_part(pid: str, members: list) -> bool:
    """Set member PIDs for collections.

    pid - Språkbanken Text resource (PID)
    members - list of members (PIDs)

    Format:
    "relatedIdentifiers": [
        {
        "relatedIdentifierType": "DOI",
        "relationType": "HasPart",
        "resourceTypeGeneral": DMS_RESOURCE_TYPE_GENERAL,
        "relatedIdentifier": "arXiv:0706.0001", # globally unique identifier, DOI, eg 10.1234/abc
        }
    ],

    YAML:
    resource:res
    in_collections:
        - superlim-1-0
    collection: true

    """
    # Build list of relatedIdentifiers
    result = ""
    for related_pid in members:
        if result:
            result += ", "
        result += (
            ', {"relatedIdentifierType": "DOI", '
            ' "relationType": "HasPart", '
            ' "resourceTypeGeneral": '
            + DMS_RESOURCE_TYPE_GENERAL +
            + ", "
            + ' "relatedIdentifier": "'
            + related_pid
            + '"}'
        )

    # Build json payload
    data_json = {
        "data": {
            "type": "dois",
            "attributes": {
                # 12. Rn. Related identifier (set later for collections)
                "relatedIdentifiers": [result]
            },
        }
    }

    # Update resource
    url = DMS_URL + "/" + pid
    response = requests.put(
        url, json=data_json, headers=DMS_HEADERS, auth=HTTPBasicAuth(DMS_AUTH_USER, DMS_AUTH_PASSWORD)
    )

    # dict = response.json()
    return response.status_code == RESPONSE_OK


def set_dms_is_part_of(pid: str, collections: list) -> bool:
    """Set collection PIDs for members.

    pid - Språkbanken Text resource (PID)
    collections - list of collections (PIDs)

    Format:
    "relatedIdentifiers": [
        {
        "relatedIdentifierType": "DOI",
        "relationType": "IsPartOf",
        "resourceTypeGeneral": DMS_RESOURCE_TYPE_GENERAL,
        "relatedIdentifier": "<DOI>"
        }
    ],

    """
    # Build list of relatedIdentifiers
    result = ""
    for related_pid in collections:
        if result:
            result += ", "
        result += (
            ', {"relatedIdentifierType": "DOI", '
            ' "relationType": "IsPartOf", '
            ' "resourceTypeGeneral": '
            + DMS_RESOURCE_TYPE_GENERAL +
            + ", "
            + ' "relatedIdentifier": "'
            + related_pid
            + '"}'
        )

    # Build json payload
    data_json = {
        "data": {
            "type": "dois",
            "attributes": {
                # 12. Rn. Related identifier (set later for collections)
                "relatedIdentifiers": [result]
            },
        }
    }

    # Update resource
    url = DMS_URL + "/" + pid
    response = requests.put(
        url, json=data_json, headers=DMS_HEADERS, auth=HTTPBasicAuth(DMS_AUTH_USER, DMS_AUTH_PASSWORD)
    )

    # dict = response.json()
    return response.status_code == RESPONSE_OK


def get_dms_lookup_pid(res_id: str) -> str:
    """Metadata.yaml could be autogenerated, so look up if existing at DC.

    https://support.datacite.org/docs/api-queries
    curl https://api.datacite.org/dois?query=creators.nameIdentifiers.nameIdentifierScheme:ORCID

    https://support.datacite.org/docs/api-queries

    "alternateIdentifiers": [
    {
        "alternateIdentifierType": "resource ID",
        "alternateIdentifier": res_id
    },

    Use dict.get() to provide a default value when the key does not exist:
    """
    search_url = DMS_URL + DMS_PREFIX + "?query=alternateIdentifiers.alternateIdentifier:" + res_id
    response = requests.post(
        search_url
    )  # , headers = DMS_HEADERS, auth=HTTPBasicAuth(DMS_AUTH_USER, DMS_AUTH_PASSWORD))
    if response.status_code == 200: # TODO
        d = response.json()
        if "data" in d:
            data = d["data"]
            if type(data) is list:  # noqa: SIM108
                # TODO This should never happen, as res_id should be unique among Språkbanken Text
                pid = data[0]["id"]
            else:
                pid = data["id"]
        else:
            # print(d["errors"][0]["status"]) # returns "404"
            pid = ""
    else:
        # print(d["errors"][0]["status"]) # returns "404" or 405?
        pid = ""
    return pid


if __name__ == "__main__":
    args = parser.parse_args()
    main(debug=args.debug, test=args.test)
